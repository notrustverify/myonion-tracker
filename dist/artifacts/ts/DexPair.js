"use strict";
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DexPairInstance = exports.DexPair = void 0;
const web3_1 = require("@alephium/web3");
const DexPair_ral_json_1 = __importDefault(require("../trade/DexPair.ral.json"));
const contracts_1 = require("./contracts");
const types_1 = require("./types");
class Factory extends web3_1.ContractFactory {
    constructor() {
        super(...arguments);
        this.eventIndex = { Trade: 0 };
        this.consts = {
            MINIMUM_AMOUNT: BigInt("10000"),
            ErrorCodes: {
                ReserveOverflow: BigInt("1"),
                InsufficientLiquidity: BigInt("5"),
                InvalidK: BigInt("6"),
                InsufficientOutputAmount: BigInt("7"),
                InvalidInputAmount: BigInt("8"),
                InputTooLarge: BigInt("9"),
                InsufficientFee: BigInt("10"),
            },
        };
        this.tests = {
            getProtocolFeeCollector: async (params) => {
                return (0, web3_1.testMethod)(this, "getProtocolFeeCollector", params, contracts_1.getContractByCodeHash);
            },
            getRoyaltyFeeCollector: async (params) => {
                return (0, web3_1.testMethod)(this, "getRoyaltyFeeCollector", params, contracts_1.getContractByCodeHash);
            },
            getTokenPair: async (params) => {
                return (0, web3_1.testMethod)(this, "getTokenPair", params, contracts_1.getContractByCodeHash);
            },
            getReserves: async (params) => {
                return (0, web3_1.testMethod)(this, "getReserves", params, contracts_1.getContractByCodeHash);
            },
            validateReserve: async (params) => {
                return (0, web3_1.testMethod)(this, "validateReserve", params, contracts_1.getContractByCodeHash);
            },
            update: async (params) => {
                return (0, web3_1.testMethod)(this, "update", params, contracts_1.getContractByCodeHash);
            },
            estimateOutput: async (params) => {
                return (0, web3_1.testMethod)(this, "estimateOutput", params, contracts_1.getContractByCodeHash);
            },
            swap: async (params) => {
                return (0, web3_1.testMethod)(this, "swap", params, contracts_1.getContractByCodeHash);
            },
        };
    }
    encodeFields(fields) {
        return (0, web3_1.encodeContractFields)((0, web3_1.addStdIdToFields)(this.contract, fields), this.contract.fieldsSig, types_1.AllStructs);
    }
    at(address) {
        return new DexPairInstance(address);
    }
    stateForTest(initFields, asset, address) {
        return this.stateForTest_(initFields, asset, address, undefined);
    }
}
// Use this object to test and deploy the contract
exports.DexPair = new Factory(web3_1.Contract.fromJson(DexPair_ral_json_1.default, "", "080844157ec1adcd711a727e6b36f638c3b7a35fa19c2734d3d41c9ac2e506ed", types_1.AllStructs));
// Use this class to interact with the blockchain
class DexPairInstance extends web3_1.ContractInstance {
    constructor(address) {
        super(address);
        this.view = {
            getProtocolFeeCollector: async (params) => {
                return (0, web3_1.callMethod)(exports.DexPair, this, "getProtocolFeeCollector", params === undefined ? {} : params, contracts_1.getContractByCodeHash);
            },
            getRoyaltyFeeCollector: async (params) => {
                return (0, web3_1.callMethod)(exports.DexPair, this, "getRoyaltyFeeCollector", params === undefined ? {} : params, contracts_1.getContractByCodeHash);
            },
            getTokenPair: async (params) => {
                return (0, web3_1.callMethod)(exports.DexPair, this, "getTokenPair", params === undefined ? {} : params, contracts_1.getContractByCodeHash);
            },
            getReserves: async (params) => {
                return (0, web3_1.callMethod)(exports.DexPair, this, "getReserves", params === undefined ? {} : params, contracts_1.getContractByCodeHash);
            },
            validateReserve: async (params) => {
                return (0, web3_1.callMethod)(exports.DexPair, this, "validateReserve", params, contracts_1.getContractByCodeHash);
            },
            update: async (params) => {
                return (0, web3_1.callMethod)(exports.DexPair, this, "update", params, contracts_1.getContractByCodeHash);
            },
            estimateOutput: async (params) => {
                return (0, web3_1.callMethod)(exports.DexPair, this, "estimateOutput", params, contracts_1.getContractByCodeHash);
            },
            swap: async (params) => {
                return (0, web3_1.callMethod)(exports.DexPair, this, "swap", params, contracts_1.getContractByCodeHash);
            },
        };
        this.transact = {
            getProtocolFeeCollector: async (params) => {
                return (0, web3_1.signExecuteMethod)(exports.DexPair, this, "getProtocolFeeCollector", params);
            },
            getRoyaltyFeeCollector: async (params) => {
                return (0, web3_1.signExecuteMethod)(exports.DexPair, this, "getRoyaltyFeeCollector", params);
            },
            getTokenPair: async (params) => {
                return (0, web3_1.signExecuteMethod)(exports.DexPair, this, "getTokenPair", params);
            },
            getReserves: async (params) => {
                return (0, web3_1.signExecuteMethod)(exports.DexPair, this, "getReserves", params);
            },
            validateReserve: async (params) => {
                return (0, web3_1.signExecuteMethod)(exports.DexPair, this, "validateReserve", params);
            },
            update: async (params) => {
                return (0, web3_1.signExecuteMethod)(exports.DexPair, this, "update", params);
            },
            estimateOutput: async (params) => {
                return (0, web3_1.signExecuteMethod)(exports.DexPair, this, "estimateOutput", params);
            },
            swap: async (params) => {
                return (0, web3_1.signExecuteMethod)(exports.DexPair, this, "swap", params);
            },
        };
    }
    async fetchState() {
        return (0, web3_1.fetchContractState)(exports.DexPair, this);
    }
    async getContractEventsCurrentCount() {
        return (0, web3_1.getContractEventsCurrentCount)(this.address);
    }
    subscribeTradeEvent(options, fromCount) {
        return (0, web3_1.subscribeContractEvent)(exports.DexPair.contract, this, options, "Trade", fromCount);
    }
    async multicall(callss) {
        return await (0, web3_1.multicallMethods)(exports.DexPair, this, callss, contracts_1.getContractByCodeHash);
    }
}
exports.DexPairInstance = DexPairInstance;
